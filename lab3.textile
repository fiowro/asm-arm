h1. ЛАБОРАТОРНАЯ РАБОТА 3



Цель: Научиться работать с файлом листинга; изучить дополнительные приёмы компоновки и использования директив объявления данных; научиться программировать ветвления в ассемблерной программе и вести простой диалог через устройство ввода вывода.



h2. Краткие теоретические сведения

h3. Файл листинга

h4. Назначение листинга

Листинг - это один из выходных файлов,  создаваемых транслятором. Он имеет текстовый вид и нужен при  отладке  программы,  т.к.  кроме строк самой программы содержит дополнительную информацию.

Обычно as  создает в результате ассемблирования только объектный файл. Получить файл листинга можно, указав ключ <pre>-a</pre> и задав имя файла листинга в командной строке. Например:

<pre><code>$ arm-none-linux-gnueabi-as -a main.lst main.asm</code></pre>

h4. Структура листинга

Строки в первой части листинга имеют следующую структуру:

  17   00000014  CD80  add r1, r2, r3   @сложение чисел

└──┬─┘└───┬────┘└──┬─┘└────────────────┬─────────────────┘
   │      │        │                   └── исходный текст программы
   │      │        └── машинный код
   │      └── адрес
   └── номер строки

Все ошибки и предупреждения, обнаруженные при ассемблировании, транслятор выводит на экран и файл листинга не создается.

"Номер строки" представляет  собой номер строки файла листинга. Номера строк особенно полезны при работе с перекрестными ссылками.

Учтите, что номера строк в поле "номер строки" - это не номера строк исходного модуля.  Например,  при расширении макрокоманды  или  включении файла отсчет строк продолжается, хотя текущая строка в исходном файле остается той же.  Чтобы перевести номер строки (сгенерированный,  например, при создании перекрестных ссылок), вы должны найти соответствующую строку в листинге, а затем (по номеру или на глаз) найти ее в исходном файле.

"Адрес" -  это смещение машинного кода от начала текущего сегмента.

"Машинный код" представляет  собой действительную последовательность шестнадцатеричного значения байт и слов,  которые ассемблируются из соответствующей исходной строки программы. Информация  справа  от  данной инструкции  - это машинный код,  в который ассемблируется инструкция.       

Наконец, поле  "исходный текст программы" - это просто строка исходной программы вместе с комментариями. Некоторые строки на языке ассемблера (например,  строки, содержащие только комментарии) не генерируют никакого машинного кода, и поля "смещение" и "исходный текст программы" в таких строках отсутствуют. Тем не менее номер строки им присваивается.

Подробнее о содержимом и об опциях создания файла листинга можно прочесть man as.


h3. Описание инструкций. Команды условного перехода

Мнемоника перехода связана со значением анализируемых флагов либо со способом формирования этих флагов. Чаще всего программисты формируют флаги, проверяя отношение между двумя операндами op1 <отношение> op2, для чего выполняется команда вычитания или команда сравнения. Команда сравнения имеет мнемонический код операции cmp и такой же формат, как и команда вычитания:

<pre><code>cmp op1,op2</code></pre>

Она и выполняется точно так же, как команда вычитания за исключением того, что разность не записывается на место первого операнда. Таким образом, единственным результатом команды сравнения является формирование флагов, которые устанавливаются так же, как и при выполнении команды вычитания. Команды этой группы выполняют условный переход в зависимости от состояния флагов регистра CPSR. Синтаксис этих команд в ассемблере приведен в таблице.

!lab3_fig1.png!

Команда с кодом условия <pre><code>Cond = 1110</code></pre> - неопределенная команда, поэтому не должна использоваться. Команда с кодом условия <pre><code>Cond = 1111 фактически является командой программного прерывания <pre><code>SWI.


h2. Скрипт-файлы компоновщика

Как упоминалось ранее, объединение и размещение секций выполняет компоновцик. С помощью специального скрипта компоновщика программист может управлять тем, как именно объединяются секции и в какой области памяти они размещаются. Ниже приведён пример очень простого скрипта.

<pre><code>
SECTIONS { ❶
        . = 0x00000000; ❷
        .text : { ❸
                abc.o (.text);
                def.o (.text);
        } ❹
}
</code></pre>

#. Команда SECTIONS определяет, как будут объединены секции и куда они должны быть помещены.
#. В блоке, следующем после команды SECTIONS, приводится численное значение  -  счётчик размещений. Размещение всегда инициализируется значением 0x0. Его можно проинициализировать каким-либо другим значением. В данном случае установка нами значения в ноль  --  избыточное действие.
#. - 4. Эта часть скрипта определяет, что секции .text из исходных файлов abc.o и def.o должны перейти в секцию .text выходного файла.

Скрипт компоновщика можно упростить указанием символа «*» вместо имён файлов:
<pre><code>
SECTIONS {
        . = 0x00000000;
        .text : { * (.text); }
}
</code></pre>

Если программа содержит обе секции (.text и .data), то объединение и размещение секции .data можно выполнить следующим образом:
<pre><code>
SECTIONS {
         . = 0x00000000;
         .text : { * (.text); }
         . = 0x00000400;
         .data : { * (.data); }
}
</code></pre>

Здесь секция .text помещается по адресу 0x0, а секция .data по адресу 0x400. Если же счётчику размещений не были присвоены конкретные значения, то секции помещаются в соседних областях памяти.



h3. Пример скрипта компоновщика



Используем последний пример скрипта для управления расположением программных секций .text и .data. Для этой цели воспользуемся слегка модифицированной версией программы для вычисления суммы элементов массива:
<pre><code>
        .data
arr: .byte 10, 20, 25 @ Read-only array of bytes
eoa:     @ Address of end of array + 1
        .text
start:
 ldr   r0, =eoa          @ r0 = &eoa
ldr   r1, =arr          @ r1 = &arr
mov   r3, #0            @ r3 = 0
loop:       
ldrb  r2, [r1], #1      @ r2 = *r1++
add   r3, r2, r3        @ r3 += r2
cmp   r1, r0            @ if (r1 != r2)
bne   loop              @    goto loop
stop:   b stop
</code></pre>

Единственное отличие  -  то, что сейчас массив находится в секции .data. Также стоит отметить, что в этой программе не нужна инструкция для перепрыгивания через данные, т. к. скрипт корректно размещает секции .text и .data. В результате объявление данных может быть расположено в программе в любом удобном месте, а скрипт компоновщика позаботится о правильном размещении секций а памяти.

Когда программа компонуется, скрипт передаётся в качестве входных данных компоновщику, как показано в следующих командах:



<pre><code>$ arm-none-linux-gnueabi-as -o sum-data.o sum-data.s</code></pre>

<pre><code>$ arm-none-linux-gnueabi-ld -T sum-data.lds -o sum-data.elf sum-data.o</code></pre>



Опция -T sum-data.lds определяет, что файл sum-data.lds должен быть использован в качестве скрипта компоновщика. Сброс таблицы символов даст понимание того, как секции помещаются в памяти

<pre><code>$ arm-none-gnueabi-nm -n sum-data.elf
00000000 t start
0000000c t loop
0000001c t stop
00000400 d arr
00000403 d eoa
</code></pre>


Из таблицы символов становится очевидным, что секция .text размещается с адреса 0x0, а секция .data с 0x400.



h2. Больше об ассемблерных директивах



Рассмотрим еще несколько часто используемых директив на примере двух программ:

#. Программа суммы элементов массива
#. Программа, считающая длину строки.



h3. Сумма массива

Следующий код суммирует массив байт и сохраняет  результат в r3:

<pre><code>
 .text
entry: b start 
arr: .byte 10, 20, 25
eoa: 
 .align
start:
         ldr   r0, =eoa  @ r0 = &eoa
         ldr   r1, =arr  @ r1 = &arr
         mov   r3, #0   @ r3 = 0
loop:
 ldrb  r2, [r1], #1   @ r2 = *r1++
         add   r3, r2, r3  @ r3 += r2
                cmp   r1, r0                        @ if (r1 != r2)
                bne   loop                        @    goto loop
stop:        b stop
</code></pre>


В коде представлены две новые ассемблерные директивы - .byte и .align. Эти директивы описаны ниже.



h4. Директива .byte

 

Аргументы директивы .byte имеют размер 1 байт и собраны в последовательность байт в памяти. Существуют аналогичные директивы .2byte и .4byte для хранения 16 и 32 битовых значений соответственно. Общий синтаксис приведён ниже

<pre><code>.byte   exp1, exp2, ...
.2byte  exp1, exp2, ...
.4byte  exp1, exp2, ...
</code></pre>

Аргумент может быть простым целым числом представленным в двоичной, восьмеричной, десятичной или шестнадцатеричной формах. Целые числа могут также быть представлены как символьные константы (обозначены одинарными кавычками), в этом случае будет использоваться ASCII значение символа.

Аргументом могут также служить выражения составленные их букв и других символов. Например:

<pre><code>
.byte 0b01010101, 0b00110011, 0b00001111
.byte npattern - pattern
.byte 'A', 'B', 'C', 'D', 'E', 'F'
.4byte 0xDEADBEEF
.byte 'Z' - 'A' + 1
</code></pre>

h4. Директива .align



Процессору ARM требуется, чтобы инструкции были представлены в 32 битовых ячейках памяти. Адрес первого из четырёх байт должен быть кратным 4. Чтобы придерживаться этого, директива .align используется для заполнения недостающими битами до тех пор, пока адрес не будет кратным 4. Это требуется только когда данные байт или полуслов вставлены в код.



h3. Длина строки

Следующий код считает длину строки и сохраняет результат в регистр r1:
<pre><code>
 .text
 b start
str: .asciz "Hello World"
 .equ   nul, 0
 .align
start:       
ldr   r0, =str  @ r0 = &str
 mov   r1, #0
loop:       
ldrb  r2, [r0], #1  @ r2 = *(r0++)
 add   r1, r1, #1  @ r1 += 1
 cmp   r2, #nul  @ if (r1 != nul)
        bne   loop                        @    goto loop
        sub   r1, r1, #1                @ r1 -= 1
stop:       
b stop
</code></pre>


В коде представлены две новые ассемблерные директивы - .asciz и .equ. Эти директивы описаны ниже.



h4. Директива .asciz

Директива .asciz в качестве аргументов принимает строковые литералы. Строковые литералы представляют собой последовательность символов в двойных кавычках. Строковые литералы собраны в ячейки памяти последовательно. Ассемблер автоматически вставляет нули после каждой строки.

Директива .ascii аналогична .asciz, но ассемблер не вставляет нули после каждой строки.



h4. Директива .equ



Ассемблер поддерживает так называемые таблицы символов. В них содержатся имена меток с адресами. Всякий раз, когда ассемблер встречает определение метки, он делает запись в таблицу символов. Всякий раз, когда ассемблер встречает ссылку на метку, он заменяет метку соответствующим адресом из таблицы символов.

Использование директивы .equ также возможно для ручной вставки записей в таблицу символов для сопоставления имён и значений, которые не обязательно являются адресами. Эти имена и имена меток вместе называются символьными именами.

Общий синтаксис этой директивы представлен ниже.

<pre><code>.equ имя, выражение</code></pre>

Имя является символьным именем и имеет те же ограничения, что и имя метки. Выражение может быть простым литералом или выражением, описанным в директиве .byte.



h2. Организация обмена информации

Для простейшего обмена информацией программы с окружающим миром мы воспользуемся последовательной консолью. Для использования ее в эмуляторе QEMU необходимо выполнить проброс порта UART. Для диалога с ассемблерной программой мы соединим последовательную консоль эмулятора с  одной из текстовых консолей Linuх на хост-системе. Доступ к консоли будет осуществляться через виртуальный файл устройства /dev/tty?. , где знак вопроса заменяется номером консоли. Так, например, для использования шестой (последней) текстовой консоли запуск эмулятора будет иметь вид:



<pre><code>sudo qemu-system-arm -M versatilepb -nographic -m 128M -kernel flash.bin -serial /dev/tty6</code></pre>

       

(Нам пришлось использовать команду sudo чтобы иметь возможность записи в /dev/tty6).       

        Таким образом, информация будет отправляться и приниматься с двух сторон: из окружающей среды, в роли котороый выступает ОС GNU/Linux на хост-системе, и изнутри эмулятора QEMU. В qemu-system-arm в качестве  последовательного порта с нулевым номером выступает порт по адресу 0x101f1000. Поэтому для того чтобы почесть или передать байт, нужно почесть или записать байт по адресу 0x101f1000:


<pre><code>
ldr                r0, =0x101f1000        @ запись адреса в регитр r0
...
str                r1, [r0]                         @ чтение байта данных в r1 с UART
...
ldr                r1, [r0]                        @ запись данных с регистора r1 в UART
</code></pre>

h2. Задание для выполнения

#. Написать программу, работающую по следующему алгоритму:
 * вывести на экран запрос о времени дня, например, "Полдень прошел?";
 * принять с клавиатуры ответ (Y/N);
 * если было введено N, выдать сообщение "Доброе утро",  в противном случае - "Добрый день".
#. Получить файл листинга и внимательно ознакомиться с его  форматом  и  содержимым.
#. Подробно объяснить содержимое трех строк файла листинга по выбору.





h2. Контрольные вопросы



#. Для чего нужен файл листинга? В чем его отличие от текста программы?
#. Каков формат файла листинга? Из каких частей он состоит? Каково назначение первой части?
#. Каким образом в Unix-подобных ОС определяются права доступа к файлу?
#. Как ОС определяет, является ли файл исполняемым? Как регулировать права на чтение и запись?
#. Как разграничить права доступа для различных категорий пользователей?



                    
