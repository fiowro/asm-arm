h1. ЛАБОРАТОРНАЯ РАБОТА 2
Дополнительные приемы трансляции программы на языке ассемблера


h2. Краткие теоретические сведения

h3. Расширенный синтаксис командной строки GNU AS


Полный вариант командной строки as выглядит следующим образом:

<pre><code>arm-none-linux-gnueabi-as [-@ косвенный_файл_настроек] [-o объектный_файл] [-a файл листинга] [параметры...] исходный_файл</code></pre>

Для более подробной информации см. <code>man as</code>.

Пример <code>arm-none-linux-gnueabi-as -o add.o -a=add.lst add.s</code> скомпилирует исходный файл <code>add.s</code> в <code>add.o</code>, вдобавок будет создан файл листинга <code>add.lst</code>.

h3. Утилита MAKE

<code>make</code> -- утилита из набора GNU для поддержки групп программ. Она управляет трансляцией, компоновкой. Поведение make описывается формирующим файлом <code>Makefile</code>, который должен присутствовать в текущем каталоге. Это текстовый файл, который может содержать объекты трех видов:

* комментарии;
* правила;
* макроопределения.

Пример:

<pre><code>
build:
	arm-none-linux-gnueabi-as -o add.o -a=add.lst add.s
	arm-none-linux-gnueabi-ld -Ttext=0x0 -o add.elf add.o
clean:
	rm -f add.s add.o add.lst add.elf
</code></pre>


В примере созданы два правила с именами («целями») <code>build</code> и <code>clean</code>. Первое из них выполняет трансляцию и сборку программы, а второе удаляет все созданные предыдущим правилом файлы.

Таким образом, если набрать в командной строке <code>make build</code>, то будет создан исполняемый файл из <code>add.s</code>. Если набрать <code>make clean</code>, то проект будет очищен: будут удалены все файлы, создаваемые <code>as</code> и <code>ld</code>.

Для более подробной информации см. <code>man make</code>.

*ПРИМЕЧАНИЕ*: утилита <code>make</code> необычно требовательна к содержимому make-файла. Ей необходимо, чтобы команды в правилах (в отличие от целей) начинались с отступа, и отступ обязательно должен создаваться символом табуляции, а не пробелами. Например, редактор mcedit по умолчанию заменяет табуляции пробелами. Чтобы он создавал настоящую табуляцию, нужно в меню (F9) выбрать подпункт «Общая» пункта «Настройка» и убрать галочку в пункте «Симулировать неполную табуляцию».


h2. Использование RAM

Флэш-память, в которой хранилась программа из предыдущей работы, является своего рода EEPROM (англ. Electrically Erasable Programmable Read-Only Memory -- перепрограммируемое ПЗУ с электрическим стиранием). Это полезная «вторичная» память, применяемая обычно как жесткий диск, но неудобная для хранения переменных. Переменные должны быть сохранены в ОЗУ, чтобы их можно было легко изменять.

Эмулируемая пакетом QEMU плата Connex имеет 64 МБ оперативной памяти, начинающейся с адреса <code>0xA000 0000</code>, в которую можно сохранять переменные. Карту памяти платы Connex можно изобразить на рисунке:

!lab2_fig1.png!

Чтобы разместить переменные начиная с этого адреса, нужно предпринять специальные меры. Чтобы понять, что именно требуется сделать, нужно понимать роль, которую играет компоновщик (линкер).


h3. Компоновщик

Во время трансляции программы, состоящей из нескольких файлов исходного текста, каждый такой файл преобразовывается в объектный. Компоновщик объединяет эти объектные файлы в конечный исполняемый файл:

!lab2_fig2.png!

Во время компоновки линкер выполняет следующие операции:

# Разрешение символов
# Перемещение

h3. Разрешение символов

В ходе преобразования исходного файла в объектный код транслятор заменяет все ссылки на метки соответствующими адресами. В многофайловой программе, если в модуле есть какие-либо ссылки на внешние метки, определенные в другом файле, ассемблер помечает их как «нерешённые». Когда эти объектные файлы передаются компоновщику, он определяет значения адресов таких ссылок из других объектных файлов и исправляет код на правильные значения.

Рассмотрим пример, вычисляющий сумму элементов массива -- специально разделенный на два файла, чтобы было наглядно видно выполняемое компоновщиком разрешение символов. Для демонстрации наличия нерешенных ссылок соберем оба файла и проверим их таблицы символов.

Файл <code>sum-sub.s</code> содержит подпрограмму <code>sum</code>, а файл <code>main.s</code> вызывает подпрограмму с требуемым аргументом. Исходные файлы приведены ниже.

*main.s*:

<pre><code>
.text
b start
arr: .byte 10, 20, 25 	@ Массив байт (только для чтения)
eoa: 			@ Адрес конца массива + 1
.align
start:
ldr r0, =arr 		@ r0 = &arr
ldr r1, =eoa 		@ r1 = &eoa
bl sum 			@ Вызов подпрограммы sum
stop: b stop
</code></pre>

*sum-sub.s*:

<pre><code>
@ Аргументы:
@ r0: Начальный адрес массива
@ r1: Конечный адрес массива

@ Результат:
@ r3: Сумма элементов массива

	.global sum
sum: 	mov r3, #0 		@ r3 = 0
loop: 	ldrb r2, [r0], #1 	@ r2 = *r0++; Загрузка элемента массива
	add r3, r2, r3 		@ r3 += r2; Вычисление суммы
	cmp r0, r1 		@ if(r0 != r1); Проверка на конец массива
	bne loop 		@ Цикл, аналог «goto loop» архитектуры х86
	mov pc, lr 		@ pc = lr; Возврат по окончании
</code></pre>

С помощью директивы <code>.global</code> мы задали видимость объявленных в функции переменных для других файлов. Теперь компилируем фалы и просмотрим таблицу символов с помощью команды <code>nm</code>.

<pre><code>
$ arm-none-linux-gnueabi-nm main.o
00000004 t arr
00000007 t eoa
00000008 t start
00000014 t stop
	 U sum

$ arm-none-linux-gnueabi-nm sum-sub.o
00000004 t loop
00000000 T sum
</code></pre>

Одиночная буква во второй колонке определяет тип символа. Тип <code>t</code> означает, что символ определён в секции <code>.text</code>. Тип <code>u</code> определяет, что символ не определён. Заглавная буква определяет принадлежность к типу доступа <code>.global</code>. Очевидно, что символ <code>sum</code> определён в <code>sum-sub.o</code> и не описан в <code>main.o</code>, в расчете на то, что позже компоновщик преобразует символьные ссылки и создаст на выходе исполняемый файл.

h3. Перемещение

Перемещение -- процесс изменения адреса, уже заданного метке ранее, а также исправления всех ссылок для отражения вновь назначенных адресов. В первую очередь, перемещение осуществляется по следующим двум причинам:

# Слияние секций
# Размещение секций в исполняемом файле

Для понимания процесса перемещения важно понимать, что такое секции.

В момент выполнения программы код и данные могут обрабатываться по-разному: если, код можно разместить в ПЗУ (ROM, read-only memory), то для данных может потребоваться как чтение из памяти, так и запись. Удобнее всего, если код и данные не чередуются, и именно поэтому программы разделены на секции. Большинство программ имеют хотя бы две секции: <code>.text</code> для кода и <code>.data</code> для работы с данными. Для переключения между двумя секциями используются директивы ассемблера <code>.text</code> и <code>.data</code>.

Когда ассемблер встречает какую-нибудь директиву секции, он кладёт код или данные, следующие за ней, в соответствующую область памяти. Таким образом, код и данные, которые относятся к одной секции, оказываются в смежных ячейках. Процесс наглядно показан на следующем рисунке.

!lab2_fig3.png!

Использованная в примере директива <code>.skip</skip> резервирует в памяти место, равное указанному количеству байт, без их инициализации какими-либо данными.

h4. Слияние секций

В многофайловых программах секции с одинаковыми именами (например <code>.text</code>) могут оказаться в разных файлах. Компоновщик отвечает за слияние секций из входных файлов в секции выходного файла. По умолчанию секции с одинаковым именем из каждого файла размещаются по-порядку, а ссылки на метки корректируются значением нового адреса.

Результат слияния секций можно наблюдать с помощью таблицы символов объектных файлов и соответствующего исполняемого файла. Ниже результат слияния показан на примере программы вычисления суммы массива:

<pre><code>
$ arm-none-linux-gnueabi-nm main.o
00000004 t arr
00000007 t eoa
00000008 t start
00000014 t stop
	 U sum

$ arm-none-linux-gnueabi-nm sum-sub.o
00000004 t loop
00000000 T sum

$ arm-none-linux-gnueabi-ld -Ttext=0x0 -o sum.elf main.o sum-sub.o
$ arm-none-linux-gnueabi-nm sum.elf
00000004 t arr
...
00000007 t eoa
00000024 t loop
00000008 t start
	 U _start
00000014 t stop
00000020 T sum
</code></pre>

Символ <code>loop</code> имеет адрес <code>0x4</code> в файле <code>sum-sub.o</code> и <code>0x24</code> в <code>sum.elf</code>, так как секция <code>.text</code> файла <code>sum-sub.o</code> переместилась и располагается сразу после секции <code>.text</code> файла <code>main.o</code>.

h4. Размещение секций

Когда программа скомпилирована, предполагается, что каждая секция начинается с адреса <code>0</code>, а меткам приписываются значения относительно начала секции. При создании исполняемого файла секции помещаются по некоторому адресу <code>X</code>, а затем ссылки на метки, определённые в секции, увеличиваются на величину <code>X</code>.

Размещение каждой секции в конкретной области памяти и исправление всех ссылок на метки в секции производятся компоновщиком.

Результат размещения секций можно наблюдать из таблиц символов объектных и исполняемого файлов. Для лучшего понимания разместим секцию <code>.text</code> по адресу <code>0x100</code>. В результате адрес секции <code>.text</code> будет в исполняемом файле на 100 больше. Процесс объединения (section merging) и размещения (section placement) секций показан на схеме:

!lab2_fig4.png!

h2. Порядок выполнения работы

# Создайте два файла с ихсходными кодами программы, как указано в методичке. 
# Откомпилируйте и запустите программу. Убедитесь в ее работоспособности, посмотрев содержимое регистров в мониторе QEMU.
# Используйте утилиту make для автоматизации сборки программы. Измените что-либо в одном из исходных файлов и убедитесь, что пересборка проекта выполняется успешно. 

h2. Контрольные вопросы

# Каково назначение и формат косвенных командных файлов для NASM?
# Каково назначение и формат файлов подсказки для   LD?.
# Каково назначение утилиты MAKE?
# Где задаются правила поведения MAKE?
# Расскажите о размещении секций в исполняемом файле.
# Расскажите о слиянии секций в исполняемом файле.


